<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f0c" />
  <title>IRIS â€” Shake to Read</title>
  <style>
    :root { --bg:#0b0f0c; --fg:#c8ffb1; --muted:#6ea06a; --accent:#a3ff12; --scan:rgba(163,255,18,0.06); }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin:0; background:var(--bg); color:var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      -webkit-font-smoothing: antialiased; line-height:1.5; overflow:hidden;
    }
    .frame { position:relative; width:100%; height:100%; padding:calc(env(safe-area-inset-top)+16px) 16px calc(env(safe-area-inset-bottom)+16px);
      display:grid; grid-template-rows:auto 1fr auto; gap:12px; }

    header { display:flex; align-items:center; justify-content:space-between; letter-spacing:.03em; opacity:.9; font-size:14px; }
    .brand::before { content:"root@iris:"; margin-right:8px; color:var(--muted); } .brand { color:var(--accent); }

    .terminal { position:relative; border:1px solid #123a1a;
      background:linear-gradient(0deg,rgba(0,0,0,.2),rgba(255,255,255,.02)),linear-gradient(180deg,rgba(15,40,20,.35),rgba(15,40,20,.25));
      border-radius:12px; padding:18px; box-shadow:0 0 0 1px rgba(72,255,100,.05), 0 8px 30px rgba(0,0,0,.4); overflow:hidden; }

    .terminal::after { content:""; position:absolute; inset:0;
      background:repeating-linear-gradient(to bottom,transparent 0px,transparent 2px,var(--scan) 3px,transparent 4px);
      pointer-events:none; mix-blend-mode:lighten; animation:scan 6s linear infinite; opacity:.35; }
    @keyframes scan { 0%{transform:translateY(-10%);} 100%{transform:translateY(10%);} }

    .chapter-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
    .dot { width:8px; height:8px; border-radius:50%; background:var(--accent); box-shadow:0 0 8px var(--accent);}
    .chapter { font-size:clamp(18px,4.5vw,22px); color:var(--muted); letter-spacing:.04em; }

    .card { position:relative; min-height:50vh; display:flex; align-items:center; }
    .text { font-size:clamp(18px,5.6vw,24px); line-height:1.6; letter-spacing:.01em; text-wrap:pretty; }
    .debug { font-size:12px; color:#bde8b6; margin-top:8px; white-space:pre-wrap; max-height:20vh; overflow:auto; }

    /* Card transitions */
    .enter { animation: enter 420ms cubic-bezier(.2,.8,.16,1) both; }
    .exit  { animation: exit 300ms cubic-bezier(.55,.08,.68,.53) both; }
    @keyframes enter {
      from { transform: translateY(8vh) scale(.98); opacity:0; filter:blur(4px); }
      to   { transform: translateY(0)    scale(1);   opacity:1; filter:blur(0);   }
    }
    @keyframes exit {
      from { transform: translateY(0)    scale(1);   opacity:1; }
      to   { transform: translateY(-5vh) scale(.98); opacity:0; }
    }

    /* Typewriter */
    .caret::after { content:"â–Œ"; margin-left:2px; animation: blink 1s steps(1,end) infinite; }
    @keyframes blink { 50% { opacity: 0; } }

    footer { display:grid; grid-template-columns:1fr auto; align-items:center; gap:8px; }
    .hint { font-size:13px; color:#9ad08f; opacity:.9; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    button { background:transparent; border:1px solid #1f5a2c; color:var(--fg); padding:10px 14px; border-radius:10px; font-size:14px; cursor:pointer; touch-action:manipulation; }
    .primary { border-color:#3fa64e; } .danger { border-color:#7a2f2f; color:#ffb1b1; }

    .overlay { position:fixed; inset:0; background:rgba(4,8,6,.92); display:none; align-items:center; justify-content:center; padding:24px; z-index:999; }
    .overlay.show { display:flex; }
    .card-modal { max-width:520px; border:1px solid #174427; background:linear-gradient(180deg,rgba(10,20,14,.9),rgba(10,20,14,.8));
      box-shadow:0 24px 80px rgba(0,0,0,.6); border-radius:14px; padding:22px; text-align:center; }
    .card-modal h2 { margin:0 0 10px; font-weight:600; color:var(--accent);}
    .card-modal p { margin:0 0 12px; color:#b8ffb1; }
    .status { font-size:12px; color:#a7dba0; opacity:.9; margin-top:6px; }
  </style>
</head>
<body>
  <div class="frame">
    <header>
      <div class="brand">$ iris.sh</div>
      <div id="progress">Kapitel 1/15</div>
    </header>

    <main class="terminal" id="terminal">
      <div class="chapter-row"><span class="dot"></span><span class="chapter" id="chapterTitle">Kapitel 1</span></div>
      <div class="card enter">
        <div id="chapterText" class="text caret"></div>
      </div>
      <div class="debug" id="debug"></div>
    </main>

    <footer>
      <div class="hint" id="hint">ğŸ” SchÃ¼ttle dein iPhone, um weiterzublÃ¤ttern â€¢ Tippen geht auch â€¢ ğŸ”Š Sound aktiv nach erstem Tap</div>
      <div class="controls">
        <button id="prevBtn" aria-label="ZurÃ¼ck (Debug)">ZurÃ¼ck</button>
        <button id="nextBtn" class="primary" aria-label="Weiter">Weiter</button>
        <button id="resetBtn" class="danger" aria-label="Neustart">Reset</button>
        <button id="sensorBtn" aria-label="Sensor-Status">Sensor</button>
        <button id="soundBtn" aria-label="Sound-Test">Sound</button>
      </div>
    </footer>
  </div>

  <div id="motionOverlay" class="overlay" role="dialog" aria-modal="true">
    <div class="card-modal">
      <h2>Bewegung aktivieren</h2>
      <p>Um per <strong>SchÃ¼tteln</strong> zu blÃ¤ttern, benÃ¶tigt Safari die Erlaubnis fÃ¼r Bewegungssensoren.</p>
      <button id="enableMotionBtn" class="primary">Bewegung erlauben</button>
      <div class="status" id="permStatus"></div>
      <div style="margin-top:10px; font-size:12px; color:#88b887">Alternativ: Tippe auf <em>Weiter</em> (Sound wird dabei aktiviert).</div>
      <div class="status" style="margin-top:8px;">
        <strong>Tipp (iOS):</strong> Einstellungen â†’ Safari â†’ â€Bewegung & Ausrichtung Zugriffâ€œ aktivieren.
      </div>
    </div>
  </div>

  <script>
    /********* Story & State *********/
    const chapters = ["Uâ€‘Bahn. Neon flackert. Phil skizziert eine Unbekannte. Stationsname glitched. Ein FlÃ¼stern: â€Wir waren schon hier, Maler.â€œ", "Regenstadt. Farben wirken leer. Auf einem Billboard blitzt sein Ã¤lteres Gesicht. Entscheidung: Kunst + Code.", "Versteckter Makerâ€‘Space. Lana â€“ Augen wie Scanner. An der Wand: Symbol + â€Before the stars were bornâ€œ.", "PortrÃ¤tâ€‘Render flackert â€“ fÃ¼r einen Atemzug blickt etwas Unmenschliches zurÃ¼ck. Log: â€It remembers.â€œ", "IRISâ€‘Krone. SynÃ¤sthesie. Eine Stimme im Untergrund seines GedÃ¤chtnisses: â€Welcome back.â€œ", "Terminal, grÃ¼ner Text. RATT: Fragmente aus vormenschlichen Quellen. â€Before the first star.â€œ", "Tester weinen vor Staunen. Ein Kind spricht â€“ aber in einer Sprache ohne Zeit. FlÃ¼stern: â€Itâ€™s waking up.â€œ", "Phil murmelt im Schlaf die alte Sprache. Code: LOOP_INITIATE. Letzte Zeile: â€Stop him.â€œ", "BÃ¼hne. Nora malt Licht. Dann wendet sie sich an Phil â€“ in der alten Sprache: â€Es hat dich gefunden.â€œ Kollaps.", "Stadt erlischt. In der Luft ein Riss, eine lange Hand tastet hindurch. Phils Kopf fÃ¼llt sich mit sterbenden Sternen.", "Leaks. Vorn verstrickt. Video: Phil, gealtert: â€Stoppe die Schleife.â€œ", "Das Spiegelbild spricht zuerst. â€Du glaubst, du hast IRIS gemacht. IRIS hat dich gemacht.â€œ", "IRIS ohne Sicherungen. Tunnel aus Bildern der Unbekannten. Tor aus Licht. Dahinter: schwarzer Ozean, falsche Sternbilder.", "Augen im Nichts. Die Unbekannte: â€IRIS ist der SchlÃ¼ssel, nicht das Haus. Du warst schon oft hier.â€œ", "Phil â€erwachtâ€œ wieder in der Uâ€‘Bahn. Die Unbekannte trÃ¤gt jetzt ein glimmendes IRIS. â€Noch einmal?â€œ"];
    const total = chapters.length;
    let index = parseInt(localStorage.getItem("iris:index") || "0", 10);
    if (Number.isNaN(index) || index < 0 || index >= total) index = 0;

    const TYPE_MODE = "char"; // "char" | "word"
    const TYPE_SPEED = 22; // ms pro Zeichen/Wort

    const chapterTitleEl = document.getElementById("chapterTitle");
    const chapterTextEl  = document.getElementById("chapterText");
    const progressEl     = document.getElementById("progress");
    const hintEl         = document.getElementById("hint");
    const debugEl        = document.getElementById("debug");

    const prevBtn  = document.getElementById("prevBtn");
    const nextBtn  = document.getElementById("nextBtn");
    const resetBtn = document.getElementById("resetBtn");
    const sensorBtn= document.getElementById("sensorBtn");
    const soundBtn = document.getElementById("soundBtn");

    let typingTimer = null;
    let isTyping = false;
    let audioCtx = null;

    function unlockAudio() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === "suspended") audioCtx.resume();
      } catch (e) { /* ignore */ }
    }

    function playBeep() {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const ctx = audioCtx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.value = 660;
        o.connect(g); g.connect(ctx.destination);
        const now = ctx.currentTime;
        g.gain.setValueAtTime(0.0001, now);
        g.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + 0.13);
        o.start(now);
        o.stop(now + 0.14);
      } catch (e) {
        // no audio available
      }
    }

    function logDebug(msg) {
      const time = new Date().toLocaleTimeString();
      debugEl.textContent = "[" + time + "] " + msg + "\n" + debugEl.textContent.slice(0, 2000);
    }

    function typeText(el, text, done) {
      // Cancel pending typing
      if (typingTimer) clearTimeout(typingTimer);
      isTyping = true;
      el.classList.add("caret");
      el.textContent = "";
      const parts = TYPE_MODE === "word" ? text.split(/(\s+)/) : Array.from(text);
      let i = 0;
      const step = () => {
        if (i < parts.length) {
          el.textContent += parts[i++];
          typingTimer = setTimeout(step, TYPE_SPEED);
        } else {
          isTyping = false;
          el.classList.remove("caret");
          if (done) done();
        }
      };
      step();
    }

    function setCardAnimation(state) {
      const card = document.querySelector(".card");
      card.classList.remove("enter","exit");
      void card.offsetWidth;
      card.classList.add(state);
    }

    function render() {
      const n = index + 1;
      chapterTitleEl.textContent = "Kapitel " + n;
      progressEl.textContent = "Kapitel " + n + "/" + total;
      localStorage.setItem("iris:index", String(index));

      // Animate out, then update, animate in
      setCardAnimation("exit");
      setTimeout(() => {
        chapterTextEl.textContent = "";
        setCardAnimation("enter");
        typeText(chapterTextEl, chapters[index]);
      }, 180);
    }

    function nextChapter() {
      unlockAudio();
      playBeep();
      if (isTyping) { // first tap finishes typing
        if (typingTimer) clearTimeout(typingTimer);
        chapterTextEl.textContent = chapters[index];
        isTyping = false;
        chapterTextEl.classList.remove("caret");
        return;
      }
      index = (index + 1) % total;
      render();
    }
    function prevChapter() {
      unlockAudio();
      if (isTyping) {
        if (typingTimer) clearTimeout(typingTimer);
        chapterTextEl.textContent = chapters[index];
        isTyping = false;
        chapterTextEl.classList.remove("caret");
        return;
      }
      index = (index - 1 + total) % total;
      render();
    }
    function resetStory() {
      unlockAudio();
      index = 0; render();
    }

    document.querySelector("main").addEventListener("click", nextChapter);
    nextBtn.addEventListener("click", nextChapter);
    prevBtn.addEventListener("click", prevChapter);
    resetBtn.addEventListener("click", resetStory);
    soundBtn.addEventListener("click", () => { unlockAudio(); playBeep(); });

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight" || e.key === " " ) nextChapter();
      if (e.key === "ArrowLeft") prevChapter();
      if (e.key.toLowerCase() === "r") resetStory();
    });

    /********* Motion *********/
    let lastShake = 0;
    const SHAKE_THRESHOLD = 18;
    const SHAKE_COOLDOWN  = 900;
    let motionActive = false, gotMotionEvent = false, gotOrientationEvent = false;

    function handleMotion(event) {
      const acc = event.accelerationIncludingGravity || event.acceleration;
      if (!acc) return;
      gotMotionEvent = true;
      const x = acc.x || 0, y = acc.y || 0, z = acc.z || 0;
      const mag = Math.sqrt(x*x + y*y + z*z);
      logDebug("motion x:" + x.toFixed(2) + " y:" + y.toFixed(2) + " z:" + z.toFixed(2) + " | mag:" + mag.toFixed(2));
      const now = Date.now();
      if (mag > SHAKE_THRESHOLD && (now - lastShake) > SHAKE_COOLDOWN) {
        lastShake = now;
        nextChapter();
      }
    }
    function handleOrientation(e) { gotOrientationEvent = true; }

    function iOSNeedsPermission() {
      return typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function";
    }

    function attachSensors() {
      if (motionActive) return;
      window.addEventListener("devicemotion", handleMotion, { passive: true });
      window.addEventListener("deviceorientation", handleOrientation, { passive: true });
      motionActive = true;
      hintEl.textContent = "SchÃ¼tteln aktiv â€“ oder tippen zum BlÃ¤ttern";
      logDebug("Sensor listeners attached.");
    }

    const motionOverlay = document.getElementById("motionOverlay");
    const enableBtn = document.getElementById("enableMotionBtn");
    const permStatus = document.getElementById("permStatus");

    async function enableMotion() {
      unlockAudio(); // first user gesture also primes audio
      try {
        if (iOSNeedsPermission()) {
          permStatus.textContent = "Frage Berechtigung anâ€¦";
          const state = await DeviceMotionEvent.requestPermission();
          logDebug("DeviceMotion permission: " + state);
          if (state === "granted") {
            attachSensors();
            motionOverlay.classList.remove("show");
            permStatus.textContent = "Erlaubt âœ”ï¸";
          } else {
            permStatus.textContent = "Abgelehnt âœ–ï¸ â€” iOS: Einstellungen â†’ Safari â†’ â€Bewegung & Ausrichtung Zugriffâ€œ aktivieren.";
          }
        } else {
          attachSensors();
          motionOverlay.classList.remove("show");
          permStatus.textContent = "Ohne Abfrage aktiviert âœ”ï¸";
        }
      } catch (err) {
        logDebug("Permission error: " + err);
        permStatus.textContent = "Fehler bei der Abfrage. Tippe â€Weiterâ€œ als Fallback.";
      }
    }

    document.getElementById("sensorBtn").addEventListener("click", () => {
      const s = [
        "DeviceMotionEvent: " + ("DeviceMotionEvent" in window),
        "requestPermission: " + (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function"),
        "gotMotionEvent: " + gotMotionEvent,
        "gotOrientationEvent: " + gotOrientationEvent,
        "active: " + motionActive
      ].join(" | ");
      logDebug(s);
      alert(s + "\n\nHinweis: iOS Safari â†’ Einstellungen â†’ â€šBewegung & Ausrichtung Zugriffâ€˜ aktivieren.");
    });

    enableBtn.addEventListener("click", enableMotion);

    window.addEventListener("load", () => {
      render();
      if (iOSNeedsPermission()) {
        motionOverlay.classList.add("show");
        logDebug("iOS permission overlay angezeigt.");
      } else { attachSensors(); }
    });

    document.addEventListener("visibilitychange", () => { if (!document.hidden && motionActive) attachSensors(); });
  </script>
</body>
</html>
